<script>
    let racingData = [];
    let favoriteTrendsData = [];
    let showAllJockeys = false;
    let showAllTrainers = false;
    
    const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTvMVuVB0xdAbPxg9fvRHnHLZiGm0gHh4ygYSin-2lACKqhzmXtEZb78AxIru1gJl2WnD6-XfFqCoUX/pub?gid=0&single=true&output=csv';
    const FAVORITES_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTvMVuVB0xdAbPxg9fvRHN... (rest of your favorites URL)';

    // Column Indices for the main data sheet (0-indexed)
    // A=0, B=1, C=2, ..., V=21
    const COLUMN_INDICES = {
        DATE: 0,
        COURSE_SURFACE: 2,
        RACE_NAME: 3,
        WINNER_NAME: 4,
        JOCKEY_NAME: 6,
        TRAINER_NAME: 8,
        TIME: 12,
        ODDS: 15,
        RACE_CLASS: 16,
        FIELD_SIZE: 17,
        DISTANCE: 18,
        AGE: 19,
        POST_POSITION: 20,
        // The column to be used for the Performance Period Analysis (Column V)
        PERCENTAGE_PERFORMANCE: 21 
    };

    document.addEventListener('DOMContentLoaded', function() {
        loadData();
    });

    function switchView(view, event) {
        if (event) event.stopPropagation();
        
        document.querySelectorAll('.view-container').forEach(el => {
            el.classList.remove('active');
        });
        document.getElementById(view + '-view').classList.add('active');
        
        document.querySelectorAll('.nav-item').forEach(el => {
            el.classList.remove('active');
        });
        
        if (event && event.target) {
            event.target.classList.add('active');
        }

        if (view === 'courses') {
            updateCourseAnalysis();
            loadFavoriteTrends();
        } else if (view === 'trainers') {
            populateTrainerFilters();
            updateTrainerAnalysis();
        }
    }

    async function loadData() {
        try {
            document.getElementById('syncStatus').textContent = 'Loading...';
            document.getElementById('syncStatus').style.background = '#f59e0b';
            
            const response = await fetch(SHEET_URL);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const text = await response.text();
            racingData = parseCSV(text);
            
            if (racingData.length > 0) {
                console.log('Data loaded:', racingData.length, 'races');
                populateFilters();
                updateDashboard();
                document.getElementById('syncStatus').textContent = racingData.length + ' races loaded';
                document.getElementById('syncStatus').style.background = '#22c55e';
            } else {
                throw new Error('No data found');
            }
        } catch (error) {
            console.error('Error:', error);
            document.getElementById('syncStatus').textContent = 'Error';
            document.getElementById('syncStatus').style.background = '#dc2626';
        }
    }

    async function loadFavoriteTrends() {
        try {
            const response = await fetch(FAVORITES_URL);
            const text = await response.text();
            favoriteTrendsData = parseFavoriteTrendsCSV(text);
            console.log('Favorite trends loaded:', favoriteTrendsData.length, 'entries');
            updateFavoriteAnalysis();
        } catch (error) {
            console.error('Favorite trends error:', error);
            document.getElementById('favoriteAnalysis').innerHTML = '<p class="error-message">Error loading favorite trends data.</p>';
        }
    }

    function parseCSV(csv) {
        const lines = csv.split('\n');
        if (lines.length === 0) return [];
        
        const headers = lines[0].split(',');
        const data = [];
        
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            // Simple split, handles most CSV cases unless data contains commas
            const values = line.split(',');

            if (values.length === headers.length) {
                const race = {
                    date: values[COLUMN_INDICES.DATE],
                    course_surface: values[COLUMN_INDICES.COURSE_SURFACE],
                    race_name: values[COLUMN_INDICES.RACE_NAME],
                    winner_name: values[COLUMN_INDICES.WINNER_NAME],
                    jockey_name: values[COLUMN_INDICES.JOCKEY_NAME],
                    trainer_name: values[COLUMN_INDICES.TRAINER_NAME],
                    time: parseFloat(values[COLUMN_INDICES.TIME]),
                    odds: parseFloat(values[COLUMN_INDICES.ODDS]),
                    race_class: values[COLUMN_INDICES.RACE_CLASS],
                    field_size: parseInt(values[COLUMN_INDICES.FIELD_SIZE]),
                    distance: parseFloat(values[COLUMN_INDICES.DISTANCE]),
                    age: parseInt(values[COLUMN_INDICES.AGE]),
                    post_position: parseInt(values[COLUMN_INDICES.POST_POSITION]),
                    percentage_performance: parseFloat(values[COLUMN_INDICES.PERCENTAGE_PERFORMANCE]) || 0 // **IMPORTANT: Ensure this is parsed as a number**
                    // ... other fields if needed ...
                };
                data.push(race);
            }
        }
        return data;
    }

    function parseFavoriteTrendsCSV(csv) {
        // Simple CSV parsing for the smaller trends sheet
        const lines = csv.split('\n');
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            const values = line.split(',');
            if (values.length >= 7) { // Ensure at least enough columns for the analysis
                data.push({
                    course: values[0].trim(),
                    surface: values[1].trim(),
                    fav_wins: parseInt(values[2]) || 0,
                    longshot_wins: parseInt(values[3]) || 0,
                    total_races: parseInt(values[4]) || 0,
                    // Columns E, F, G are 4, 5, 6
                });
            }
        }
        return data;
    }

    function getSelectedOptions(selectId) {
        const select = document.getElementById(selectId);
        if (!select) return [];
        const selected = Array.from(select.options)
            .filter(option => option.selected && option.value !== 'all')
            .map(option => option.value);
        return selected.length > 0 ? selected : ['all'];
    }

    function getFilteredData(view = 'courses') {
        if (racingData.length === 0) return [];
        
        let courseFilters, monthFilters, classFilters, fieldFilters, distanceFilters;

        if (view === 'courses') {
            courseFilters = getSelectedOptions('courseFilter');
            monthFilters = getSelectedOptions('monthFilter');
            classFilters = getSelectedOptions('classFilter');
            fieldFilters = getSelectedOptions('fieldFilter').map(Number);
            distanceFilters = getSelectedOptions('distanceFilter').map(Number);
        } else if (view === 'trainers') {
            courseFilters = getSelectedOptions('trainerCourseFilter');
            monthFilters = getSelectedOptions('trainerMonthFilter');
            classFilters = getSelectedOptions('trainerClassFilter');
            distanceFilters = getSelectedOptions('trainerDistanceFilter').map(Number);
            const ageFilters = getSelectedOptions('trainerAgeFilter');

            // Apply Trainer specific filters first
            const trainerFilters = getSelectedOptions('trainerAnalysisFilter');
            if (trainerFilters.includes('all') && trainerFilters.length > 1) {
                trainerFilters.shift(); // Remove 'all' if others are selected
            }
            if (!trainerFilters.includes('all') && trainerFilters.length > 0) {
                 racingData = racingData.filter(race => trainerFilters.includes(race.trainer_name));
            }

            // Age filtering logic
            if (!ageFilters.includes('all') && ageFilters.length > 0) {
                racingData = racingData.filter(race => {
                    const raceAge = race.age;
                    return ageFilters.some(filter => {
                        if (filter === '4+') {
                            return raceAge >= 4;
                        }
                        return raceAge === parseInt(filter);
                    });
                });
            }
        }
        
        const filtered = racingData.filter(race => {
            const raceMonth = race.date ? race.date.substring(5, 7) : null;

            const passesCourse = courseFilters.includes('all') || courseFilters.some(filter => race.course_surface.includes(filter));
            const passesMonth = monthFilters.includes('all') || (raceMonth && monthFilters.includes(raceMonth));
            const passesClass = classFilters.includes('all') || classFilters.includes(race.race_class);
            const passesField = view === 'trainers' || fieldFilters.includes('all') || fieldFilters.includes(race.field_size);
            const passesDistance = distanceFilters.includes('all') || distanceFilters.includes(race.distance);

            return passesCourse && passesMonth && passesClass && passesField && passesDistance;
        });

        return filtered;
    }

    // --- Trainer Analysis Functions ---

    function populateTrainerFilters() {
        if (racingData.length === 0) return;

        const allTrainers = [...new Set(racingData.map(r => r.trainer_name))].sort();
        const allCourses = [...new Set(racingData.map(r => r.course_surface))].sort();
        const allClasses = [...new Set(racingData.map(r => r.race_class))].sort();
        const allDistances = [...new Set(racingData.map(r => r.distance))].map(d => d.toFixed(0)).sort((a, b) => a - b);

        const trainerSelect = document.getElementById('trainerAnalysisFilter');
        const courseSelect = document.getElementById('trainerCourseFilter');
        const classSelect = document.getElementById('trainerClassFilter');
        const distanceSelect = document.getElementById('trainerDistanceFilter');

        // Clear existing options (except 'All')
        [trainerSelect, courseSelect, classSelect, distanceSelect].forEach(select => {
            Array.from(select.options).filter(o => o.value !== 'all').forEach(o => o.remove());
        });

        allTrainers.forEach(trainer => {
            if (trainer) trainerSelect.appendChild(new Option(trainer, trainer));
        });
        allCourses.forEach(course => {
            if (course) courseSelect.appendChild(new Option(course, course));
        });
        allClasses.forEach(raceClass => {
            if (raceClass) classSelect.appendChild(new Option(raceClass, raceClass));
        });
        allDistances.forEach(distance => {
            if (distance) distanceSelect.appendChild(new Option(distance + 'm', parseFloat(distance)));
        });

        // Set default date to today or latest race date
        const analysisDateInput = document.getElementById('analysisDate');
        if (!analysisDateInput.value) {
            const latestDate = racingData.reduce((maxDate, race) => {
                return race.date > maxDate ? race.date : maxDate;
            }, '');
            analysisDateInput.value = latestDate || new Date().toISOString().split('T')[0];
        }
    }

    // New or heavily modified function for the core fix
    function calculateTrainerPerformance(filteredData, trainerName, metricIndex) {
        const trainerData = filteredData.filter(race => race.trainer_name === trainerName);
        if (trainerData.length === 0) {
            return { runs: 0, wins: 0, avgMetric: 0 };
        }

        const runs = trainerData.length;
        const wins = trainerData.filter(race => race.winner_name === race.name).length; // Assuming a 'name' field for the horse's name
        
        let metricSum = 0;
        let metricCount = 0;

        // Use the metricIndex (which is COLUMN_INDICES.PERCENTAGE_PERFORMANCE = 21)
        const metricKey = Object.keys(COLUMN_INDICES).find(key => COLUMN_INDICES[key] === metricIndex);

        trainerData.forEach(race => {
            const metricValue = race[metricKey.toLowerCase()];
            if (typeof metricValue === 'number' && !isNaN(metricValue)) {
                metricSum += metricValue;
                metricCount++;
            }
        });

        const avgMetric = metricCount > 0 ? (metricSum / metricCount) : 0;
        
        return {
            runs,
            wins,
            avgMetric
        };
    }
    
    // New or heavily modified function for the core fix
    function getTrainerPerformanceForPeriod(filteredData, trainerName, days, analysisDateStr) {
        const analysisDate = new Date(analysisDateStr);
        // Calculate the start date for the period
        const startDate = new Date(analysisDate);
        startDate.setDate(analysisDate.getDate() - days);
        
        // Filter data for the specific trainer and period
        const periodData = filteredData.filter(race => {
            const raceDate = new Date(race.date);
            return race.trainer_name === trainerName && raceDate >= startDate && raceDate <= analysisDate;
        });

        // Use the corrected index for Percentage Performance (Column V is index 21)
        return calculateTrainerPerformance(periodData, trainerName, COLUMN_INDICES.PERCENTAGE_PERFORMANCE);
    }
    
    // New or heavily modified function for the core fix
    function displayPerformance(id, results, metricName) {
        const container = document.getElementById(id);
        if (!container) return;

        let html = '';
        if (results.runs > 0) {
            const winPct = results.runs > 0 ? ((results.wins / results.runs) * 100).toFixed(1) : '0.0';
            const avgMetricFormatted = results.avgMetric.toFixed(2);
            
            html = `
                <p>Runs: <strong>${results.runs}</strong></p>
                <p>Wins: <strong>${results.wins}</strong> (${winPct}%)</p>
                <p>Avg. ${metricName}: <strong>${avgMetricFormatted}%</strong></p>
            `;
        } else {
            html = '<p>No races in this period with current filters.</p>';
        }
        container.innerHTML = html;
    }

    // New or heavily modified function for the core fix
    function updateTrainerAnalysis() {
        const selectedTrainers = getSelectedOptions('trainerAnalysisFilter');
        const trainerSelect = document.getElementById('trainerAnalysisFilter');
        const analysisDateStr = document.getElementById('analysisDate').value;
        
        const filteredData = getFilteredData('trainers');
        
        // Handle Trainer Basic Stats and Metrics
        document.getElementById('trainerBasicStats').innerHTML = '<p class="loading">Calculating...</p>';
        document.getElementById('trainerDetailedMetrics').innerHTML = '<p class="loading">Calculating...</p>';
        document.getElementById('performance1Month').innerHTML = '<p class="loading">Calculating...</p>';
        document.getElementById('performance3Months').innerHTML = '<p class="loading">Calculating...</p>';
        document.getElementById('performance12Months').innerHTML = '<p class="loading">Calculating...</p>';
        document.getElementById('horseDropdown').innerHTML = '<option value="">Select a horse to see details...</option>';
        document.getElementById('horseDetails').innerHTML = '<p>Select a horse from the dropdown to see race details.</p>';

        if (selectedTrainers.includes('all') && trainerSelect.options.length > 1) {
             // If 'All Trainers' is selected, use the first actual trainer from the list for the display
             // This is a common UI pattern to avoid showing aggregated data of 'all' trainers 
             // in a specific trainer's stats box. You might adjust this.
             const firstTrainerOption = trainerSelect.options[1].value;
             if (firstTrainerOption) {
                 selectedTrainers.length = 0;
                 selectedTrainers.push(firstTrainerOption);
             } else {
                 document.getElementById('trainerBasicStats').innerHTML = '<p>No trainers found matching filters.</p>';
                 return;
             }
        }
        
        if (selectedTrainers.length === 0) {
            document.getElementById('trainerBasicStats').innerHTML = '<p>Select a trainer to see their analysis.</p>';
            return;
        }

        const trainerName = selectedTrainers[0]; // Only show one trainer's stats at a time

        // Calculate period performance for the selected trainer
        const performance1Month = getTrainerPerformanceForPeriod(filteredData, trainerName, 30, analysisDateStr);
        const performance3Months = getTrainerPerformanceForPeriod(filteredData, trainerName, 90, analysisDateStr);
        const performance12Months = getTrainerPerformanceForPeriod(filteredData, trainerName, 365, analysisDateStr);
        
        // **This is the key fix:** Change metric name and ensure percentage is displayed
        const metricLabel = "Percentage Performance";
        displayPerformance('performance1Month', performance1Month, metricLabel);
        displayPerformance('performance3Months', performance3Months, metricLabel);
        displayPerformance('performance12Months', performance12Months, metricLabel);

        // --- Rest of the Trainer Analysis Logic (Not modified in core logic) ---
        
        // Populate Horse Dropdown for the selected trainer
        const trainerRaces = filteredData.filter(race => race.trainer_name === trainerName);
        const uniqueHorses = [...new Set(trainerRaces.map(r => r.winner_name))].sort();
        const horseDropdown = document.getElementById('horseDropdown');
        uniqueHorses.forEach(horse => {
            if (horse) horseDropdown.appendChild(new Option(horse, horse));
        });

        // Basic Stats (Uses all filtered data for the selected trainer)
        const trainerStats = calculateTrainerStats(trainerRaces);
        updateTrainerBasicStats(trainerName, trainerStats);

        // Detailed Metrics (You'll need to define this function, using dummy data here)
        updateTrainerDetailedMetrics(trainerName, trainerStats);
    }
    
    // Helper function for the basic trainer stats table (implement or adapt this based on your needs)
    function calculateTrainerStats(trainerRaces) {
        if (trainerRaces.length === 0) return { runs: 0, wins: 0, winPct: 0, avgOdds: 0, totalPrize: 0, winRate: 0 };
        
        const runs = trainerRaces.length;
        const wins = trainerRaces.filter(r => r.winner_name === r.name).length; // Assuming r.name is the horse's name
        const winPct = runs > 0 ? (wins / runs * 100) : 0;
        const avgOdds = trainerRaces.reduce((sum, r) => sum + r.odds, 0) / runs;
        // Assuming there's a 'Prize Money' column (not visible in the first 22 columns/V)
        const totalPrize = 0; // Placeholder
        
        return {
            runs: runs,
            wins: wins,
            winPct: winPct.toFixed(1),
            avgOdds: avgOdds.toFixed(2),
            totalPrize: totalPrize.toFixed(0)
        };
    }
    
    function updateTrainerBasicStats(trainerName, stats) {
        document.getElementById('trainerBasicStats').innerHTML = `
            <h4>${trainerName}'s Overall Stats (Filtered)</h4>
            <ul style="list-style: none; padding-left: 0;">
                <li><strong>Runs:</strong> ${stats.runs}</li>
                <li><strong>Wins:</strong> ${stats.wins}</li>
                <li><strong>Win Rate:</strong> ${stats.winPct}%</li>
                <li><strong>Avg. Winning Odds:</strong> ${stats.avgOdds}</li>
                <li><strong>Total Prize Money:</strong> ${stats.totalPrize} (Placeholder)</li>
            </ul>
        `;
    }
    
    function updateTrainerDetailedMetrics(trainerName, stats) {
        document.getElementById('trainerDetailedMetrics').innerHTML = `
            <h4>${trainerName}'s Detailed Metrics (Filtered)</h4>
            <table style="width: 100%;">
                <thead>
                    <tr><th>Metric</th><th>Value</th></tr>
                </thead>
                <tbody>
                    <tr><td>Win Rate on Turf</td><td>--</td></tr>
                    <tr><td>Win Rate on All-Weather</td><td>--</td></tr>
                    <tr><td>Win Rate with Jock X</td><td>--</td></tr>
                    <tr><td>Best Horse Name</td><td>--</td></tr>
                </tbody>
            </table>
        `;
    }
    
    // Function to handle horse details dropdown (implement or adapt this)
    function updateHorseDetails() {
        const horseName = document.getElementById('horseDropdown').value;
        const filteredData = getFilteredData('trainers');
        const horseRaces = filteredData.filter(race => race.winner_name === horseName);

        if (!horseName) {
            document.getElementById('horseDetails').innerHTML = '<p>Select a horse from the dropdown to see race details.</p>';
            return;
        }

        let html = `
            <h4 style="margin-bottom: 1rem;">Race History for ${horseName} (Races: ${horseRaces.length})</h4>
            <table style="width: 100%; font-size: 0.85rem;">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Course</th>
                        <th>Distance</th>
                        <th>Class</th>
                        <th>Odds</th>
                        <th>Per. Perf.</th>
                    </tr>
                </thead>
                <tbody>
        `;

        horseRaces.sort((a, b) => new Date(b.date) - new Date(a.date)).forEach(race => {
            html += `
                <tr>
                    <td>${race.date}</td>
                    <td>${race.course_surface}</td>
                    <td>${race.distance}m</td>
                    <td>${race.race_class}</td>
                    <td>${race.odds.toFixed(1)}</td>
                    <td>${race.percentage_performance.toFixed(2)}%</td>
                </tr>
            `;
        });
        
        html += `</tbody></table>`;
        document.getElementById('horseDetails').innerHTML = html;
    }
    
    // --- End of Trainer Analysis Functions ---

    // ... (Your other functions like updateDashboard, updateCourseAnalysis, 
    // updatePostPositionAnalysis, updateWinningTimes, updateTopJockeys, 
    // updateTopTrainers, updateFieldTrends, updateWinningOdds, 
    // updateFavoriteAnalysis, toggleJockeyView, toggleTrainerView) ...
    // Note: The above functions were omitted for brevity but should remain in your code.
    
</script>
